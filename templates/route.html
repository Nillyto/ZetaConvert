{% extends "base.html" %}

{% block title %}{{ page_title }} · ZetaConvert{% endblock %}
{% block meta_desc %}{{ page_desc }}{% endblock %}
{% block og_title %}{{ page_title }}{% endblock %}
{% block og_desc %}{{ page_desc }}{% endblock %}

{% block hero %}
<section class="hero">
  <nav aria-label="breadcrumbs" class="hint">
    <a href="{{ url_for('home') }}">Inicio</a> › <span>{{ page_title }}</span>
  </nav>
  <h1>{{ page_title }}</h1>
  <p class="muted">{{ page_desc }}</p>
</section>
{% endblock %}

{% block content %}
<section class="panel converter" data-route-slug="{{ route.slug }}">
  <!-- Panel general -->
  <div class="converter-head">
    <div class="converter-head-left">
      <h2 class="h-title">{{ route.title }}</h2>
      <p class="muted">{{ route.desc }} Gratis y sin registro.</p>
    </div>

    <div class="converter-head-right">
      <label class="lbl">Formato general</label>
      <select id="targetGlobal" class="select" style="text-transform:uppercase" required
              data-route-template="{{ url_for('route_page', slug='__SLUG__') }}"
              data-current-slug="{{ route.slug }}">
        {% for t in all_targets %}
          <option value="{{ t }}" data-slug="{{ target_to_slug.get(t, '') }}"
                  {% if route.to and (t == route.to[0]) %}selected{% endif %}>
            {{ t }}
          </option>
        {% endfor %}
      </select>

      <div class="head-actions">
        <button id="btnConvertAll" class="btn primary" type="button">Convertir todo</button>
        <button id="btnDownloadAll" class="btn download" type="button" disabled>Descargar todo</button>
      </div>
    </div>
  </div>

  <!-- Dropzone -->
  <div id="dz" class="dropzone dz-pastel" tabindex="0" role="button" aria-label="Arrastrá y soltá archivos o tocá para elegir">
    <div class="dz-inner">
      <div class="dz-cta">
        <strong>Soltá tus archivos acá</strong>
        <span class="muted">o tocá para elegir</span>
      </div>
      <button id="btnPick" type="button" class="btn">Seleccionar archivos</button>
      <input id="fileInput" type="file"
             name="file{% if route.multi %}s{% endif %}"
             {% if route.multi %}multiple{% endif %}
             accept="{{ route.accept }}"
             hidden>
    </div>
  </div>

  <!-- Cola -->
  <div id="queue" class="queue mt-2" aria-live="polite" aria-relevant="additions removals">
    <!-- items dinámicos -->
  </div>
</section>

<!-- JSON del backend (dejá estos scripts tal cual) -->
<script id="map-json" type="application/json">{{ target_to_slug_json | safe }}</script>
<script id="route-from-json" type="application/json">{{ (route.exts_from or []) | tojson | safe }}</script>
<script id="route-to-json"   type="application/json">{{ (route.exts_to   or []) | tojson | safe }}</script>


<div class="actions mt-2">
  <button id="btnAdd" class="btn" type="button">Agregar archivos</button>
  <button id="btnConvertAll" class="btn primary" type="button">Convertir todo</button>
  <button id="btnClear" class="btn" type="button">Limpiar</button>
  <button id="btnDownloadAll" class="btn download" type="button">Descargar todo</button>
</div>

<section class="panel">
  <h2>Pasos</h2>
  <ol>
    <li>Elegí o arrastrá tus archivos.</li>
    <li>Seleccioná el formato.</li>
    <li>Convertí.</li>
    <li>Descargá.</li>
  </ol>
</section>

{# ===== JSON seguro inyectado por backend ===== #}
<script id="targets-json" type="application/json">{{ all_targets_json | safe }}</script>
<script id="map-json" type="application/json">{{ target_to_slug_json | safe }}</script>
{# Nuevo: exponer los orígenes/posibles destinos declarados por la ruta (para intersectar con el mapa) #}
<script id="route-from-json" type="application/json">{{ (route.exts_from or []) | tojson | safe }}</script>
<script id="route-to-json"   type="application/json">{{ (route.exts_to   or []) | tojson | safe }}</script>

{# HowTo para SEO #}
<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@type":"HowTo",
  "name":"{{ page_title }}",
  "description":"{{ page_desc }}",
  "step":[
    {"@type":"HowToStep","name":"Subir archivo","text":"Elegí o arrastrá tus archivos."},
    {"@type":"HowToStep","name":"Elegir formato","text":"Seleccioná el formato de salida."},
    {"@type":"HowToStep","name":"Convertir","text":"Hacé clic en Convertir."},
    {"@type":"HowToStep","name":"Descargar","text":"Descargá el resultado."}
  ]
}
</script>

{# ========= LÓGICA: filtrar <select id=\"target\"> por formats.status.json + formats.map.json ========= #}
<script>
document.addEventListener('DOMContentLoaded', async () => {
  const sel = document.getElementById('target');
  if (!sel) return;

  // --- Dataset que ya tenías (para redirección por slug actual) ---
  const targetToSlug = (() => {
    try { return JSON.parse(document.getElementById('map-json')?.textContent || '{}'); }
    catch { return {}; }
  })();

  // --- Orígenes/destinos declarados por la ruta (backend) ---
  const routeFrom = (() => { try { return JSON.parse(document.getElementById('route-from-json')?.textContent || '[]'); } catch { return []; } })();
  const routeTo   = (() => { try { return JSON.parse(document.getElementById('route-to-json')?.textContent   || '[]'); } catch { return []; } })();

  // --- Cargar mapa y status (desde static/) ---
  async function getJSON(url){ const r = await fetch(url, {cache:'no-store'}); if(!r.ok) throw new Error(url+' '+r.status); return await r.json(); }

  let extToId = {}, idToFmt = {}, enabledSet = new Set();

  try {
    const [mapJson, stJson] = await Promise.all([
      getJSON('/static/formats.map.json'),
      getJSON('/static/formats.status.json')
    ]);

    Object.values(mapJson?.categories || {}).forEach(arr => {
      arr.forEach(f => {
        if (f?.ext && f?.id) extToId[f.ext.toLowerCase()] = f.id;
        if (f?.id) idToFmt[f.id] = f;
      });
    });
    (stJson?.status || []).forEach(s => { if (s?.id && s.enabled === true) enabledSet.add(s.id); });
  } catch(e) {
    // Si esto falla, no filtramos (quedan las opciones SSR)
    console.warn('No se pudo cargar formats.map/status:', e);
    setupRedirectOnly();
    return;
  }

  function isEnabledExt(ext){
    const id = extToId[ext?.toLowerCase?.() || ''];
    return !!(id && enabledSet.has(id));
  }
  function enabledTargetsForExt(ext){
    const id = extToId[ext?.toLowerCase?.() || ''];
    const fmt = id && idToFmt[id];
    if (!fmt) return [];
    const outs = [];
    (fmt.targets || []).forEach(tid=>{
      if (enabledSet.has(tid)) {
        const tf = idToFmt[tid];
        if (tf?.ext) outs.push(tf.ext.toLowerCase());
      }
    });
    return outs;
  }

  // Conjunto de destinos realmente válidos: (targets de mapa habilitados) ∩ (route.to, si fue declarado)
  const allowedTargets = (() => {
    const allowed = new Set();
    // Si la ruta declara exts de origen, usamos sus targets; si no, dejamos pasar los targets globales y se filtra por enabled.
    if ((routeFrom||[]).length){
      routeFrom.forEach(fromExt => {
        if (!isEnabledExt(fromExt)) return;
        enabledTargetsForExt(fromExt).forEach(t => allowed.add(t));
      });
    }
    // Si la ruta también declara `to`, intersectamos:
    if ((routeTo||[]).length){
      const declared = new Set(routeTo.map(x=>x.toLowerCase()));
      return Array.from(allowed.size ? allowed : declared)
                  .filter(t => (!allowed.size ? true : allowed.has(t)))
                  .filter(isEnabledExt);
    }
    // Si no hay `to`, devolvemos todos los que salieron del mapa y están habilitados;
    // si `allowed` quedó vacío (no había from), mantenemos sólo los enabled globales (de las <option>)
    if (allowed.size) return Array.from(allowed).filter(isEnabledExt);

    // fallback: usar lo que ya está en el select pero filtrado por enabledSet
    return Array.from(sel.options).map(o=>o.value.toLowerCase()).filter(isEnabledExt);
  })();

  // Re-renderizar el <select> SOLO con allowedTargets:
  const currentSlug = sel.getAttribute('data-current-slug');
  const routeTpl    = sel.getAttribute('data-route-template'); // "/r/__SLUG__"
  const prevValue   = sel.value && sel.value.toLowerCase();

  sel.innerHTML = '';
  allowedTargets.forEach(t => {
    const opt = document.createElement('option');
    opt.value = t;
    opt.textContent = t.toUpperCase();
    opt.setAttribute('data-slug', (targetToSlug[t] || ''));
    sel.appendChild(opt);
  });

  // Selección por defecto:
  if (prevValue && allowedTargets.includes(prevValue)) {
    sel.value = prevValue;
  } else if (allowedTargets.length) {
    sel.value = allowedTargets[0];
  }

  // Redirección si el target pertenece a otro conversor
  setupRedirectOnly();

  function setupRedirectOnly(){
    sel.addEventListener('change', () => {
      const opt  = sel.options[sel.selectedIndex];
      const slug = opt?.getAttribute('data-slug');
      if (slug && slug !== currentSlug) {
        window.location.href = routeTpl.replace('__SLUG__', slug);
      }
      // si no cambia el slug, submit normal del form actual
    });
  }
});
</script>
{% endblock %}
