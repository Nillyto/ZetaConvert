{% extends "base.html" %}

{% block title %}{{ page_title }} · ZetaConvert{% endblock %}
{% block meta_desc %}{{ page_desc }}{% endblock %}
{% block og_title %}{{ page_title }}{% endblock %}
{% block og_desc %}{{ page_desc }}{% endblock %}

{% block hero %}
<section class="hero">
  <nav aria-label="breadcrumbs" class="hint">
    <a href="{{ url_for('home') }}">Inicio</a> › <span>{{ page_title }}</span>
  </nav>
  <h1>{{ page_title }}</h1>
  <p class="muted">{{ page_desc }}</p>
</section>
{% endblock %}

{% block content %}
<section class="panel converter" data-route-slug="{{ route.slug }}">
  <h2 class="h-title">{{ route.title }}</h2>
  <p class="muted">{{ route.desc }} Gratis y sin registro.</p>

  <form id="convertForm" action="/api/convert" method="post" enctype="multipart/form-data">
    <input type="hidden" name="route" value="{{ route.slug }}">

    <div class="grid2">
      <div>
        <label for="file">Archivo</label>
        <input id="file"
               name="file{% if route.multi %}s{% endif %}"
               type="file"
               {% if route.multi %}multiple{% endif %}
               accept="{{ route.accept }}"
               required>
      </div>

      <div>
        <label for="target">Convertir a:</label>
        <select id="target"
                name="target"
                required
                data-route-template="{{ url_for('route_page', slug='__SLUG__') }}"
                data-current-slug="{{ route.slug }}"
                style="text-transform: uppercase;">
          {# Fallback SSR: opciones base. El JS luego filtrará según status+mapa #}
          {% for t in all_targets %}
            <option value="{{ t }}"
                    data-slug="{{ target_to_slug.get(t, '') }}"
                    {% if route.to and (t == route.to[0]) %}selected{% endif %}>
              {{ t }}
            </option>
          {% endfor %}
        </select>
      </div>
    </div>

    <details class="expander mt-2"><summary>Opciones avanzadas</summary>
      <div class="grid3 mt-1">
        <label>Calidad (JPG/WEBP)<input type="range" name="quality" min="50" max="100" value="90" step="1"></label>
        <label>DPI (PDF→imagen)<input type="number" name="dpi" min="72" max="300" value="144"></label>
        <label>Páginas (PDF)<input type="text" name="pages" placeholder="1-3,5"></label>
      </div>
      <div class="grid3 mt-1">
        <label>Ancho (px)<input type="number" name="resize_w" min="0" value="0"></label>
        <label>Alto (px)<input type="number" name="resize_h" min="0" value="0"></label>
        <label class="chk"><input type="checkbox" name="stripmeta" value="1" checked> Quitar metadatos</label>
      </div>
    </details>

    <button class="btn primary" type="submit">Convertir</button>
    <div class="progress mt-2" role="progressbar" aria-label="Progreso">
      <div class="bar" id="progressBar"></div>
    </div>
  </form>
</section>

<div class="actions mt-2">
  <button id="btnAdd" class="btn" type="button">Agregar archivos</button>
  <button id="btnConvertAll" class="btn primary" type="button">Convertir todo</button>
  <button id="btnClear" class="btn" type="button">Limpiar</button>
  <button id="btnDownloadAll" class="btn download" type="button">Descargar todo</button>
</div>

<section class="panel">
  <h2>Pasos</h2>
  <ol>
    <li>Elegí o arrastrá tus archivos.</li>
    <li>Seleccioná el formato.</li>
    <li>Convertí.</li>
    <li>Descargá.</li>
  </ol>
</section>

{# ===== JSON seguro inyectado por backend ===== #}
<script id="targets-json" type="application/json">{{ all_targets_json | safe }}</script>
<script id="map-json" type="application/json">{{ target_to_slug_json | safe }}</script>
{# Nuevo: exponer los orígenes/posibles destinos declarados por la ruta (para intersectar con el mapa) #}
<script id="route-from-json" type="application/json">{{ (route.exts_from or []) | tojson | safe }}</script>
<script id="route-to-json"   type="application/json">{{ (route.exts_to   or []) | tojson | safe }}</script>

{# HowTo para SEO #}
<script type="application/ld+json">
{
  "@context":"https://schema.org",
  "@type":"HowTo",
  "name":"{{ page_title }}",
  "description":"{{ page_desc }}",
  "step":[
    {"@type":"HowToStep","name":"Subir archivo","text":"Elegí o arrastrá tus archivos."},
    {"@type":"HowToStep","name":"Elegir formato","text":"Seleccioná el formato de salida."},
    {"@type":"HowToStep","name":"Convertir","text":"Hacé clic en Convertir."},
    {"@type":"HowToStep","name":"Descargar","text":"Descargá el resultado."}
  ]
}
</script>

{# ========= LÓGICA: filtrar <select id=\"target\"> por formats.status.json + formats.map.json ========= #}
<script>
document.addEventListener('DOMContentLoaded', async () => {
  const sel = document.getElementById('target');
  if (!sel) return;

  // --- Dataset que ya tenías (para redirección por slug actual) ---
  const targetToSlug = (() => {
    try { return JSON.parse(document.getElementById('map-json')?.textContent || '{}'); }
    catch { return {}; }
  })();

  // --- Orígenes/destinos declarados por la ruta (backend) ---
  const routeFrom = (() => { try { return JSON.parse(document.getElementById('route-from-json')?.textContent || '[]'); } catch { return []; } })();
  const routeTo   = (() => { try { return JSON.parse(document.getElementById('route-to-json')?.textContent   || '[]'); } catch { return []; } })();

  // --- Cargar mapa y status (desde static/) ---
  async function getJSON(url){ const r = await fetch(url, {cache:'no-store'}); if(!r.ok) throw new Error(url+' '+r.status); return await r.json(); }

  let extToId = {}, idToFmt = {}, enabledSet = new Set();

  try {
    const [mapJson, stJson] = await Promise.all([
      getJSON('/static/formats.map.json'),
      getJSON('/static/formats.status.json')
    ]);

    Object.values(mapJson?.categories || {}).forEach(arr => {
      arr.forEach(f => {
        if (f?.ext && f?.id) extToId[f.ext.toLowerCase()] = f.id;
        if (f?.id) idToFmt[f.id] = f;
      });
    });
    (stJson?.status || []).forEach(s => { if (s?.id && s.enabled === true) enabledSet.add(s.id); });
  } catch(e) {
    // Si esto falla, no filtramos (quedan las opciones SSR)
    console.warn('No se pudo cargar formats.map/status:', e);
    setupRedirectOnly();
    return;
  }

  function isEnabledExt(ext){
    const id = extToId[ext?.toLowerCase?.() || ''];
    return !!(id && enabledSet.has(id));
  }
  function enabledTargetsForExt(ext){
    const id = extToId[ext?.toLowerCase?.() || ''];
    const fmt = id && idToFmt[id];
    if (!fmt) return [];
    const outs = [];
    (fmt.targets || []).forEach(tid=>{
      if (enabledSet.has(tid)) {
        const tf = idToFmt[tid];
        if (tf?.ext) outs.push(tf.ext.toLowerCase());
      }
    });
    return outs;
  }

  // Conjunto de destinos realmente válidos: (targets de mapa habilitados) ∩ (route.to, si fue declarado)
  const allowedTargets = (() => {
    const allowed = new Set();
    // Si la ruta declara exts de origen, usamos sus targets; si no, dejamos pasar los targets globales y se filtra por enabled.
    if ((routeFrom||[]).length){
      routeFrom.forEach(fromExt => {
        if (!isEnabledExt(fromExt)) return;
        enabledTargetsForExt(fromExt).forEach(t => allowed.add(t));
      });
    }
    // Si la ruta también declara `to`, intersectamos:
    if ((routeTo||[]).length){
      const declared = new Set(routeTo.map(x=>x.toLowerCase()));
      return Array.from(allowed.size ? allowed : declared)
                  .filter(t => (!allowed.size ? true : allowed.has(t)))
                  .filter(isEnabledExt);
    }
    // Si no hay `to`, devolvemos todos los que salieron del mapa y están habilitados;
    // si `allowed` quedó vacío (no había from), mantenemos sólo los enabled globales (de las <option>)
    if (allowed.size) return Array.from(allowed).filter(isEnabledExt);

    // fallback: usar lo que ya está en el select pero filtrado por enabledSet
    return Array.from(sel.options).map(o=>o.value.toLowerCase()).filter(isEnabledExt);
  })();

  // Re-renderizar el <select> SOLO con allowedTargets:
  const currentSlug = sel.getAttribute('data-current-slug');
  const routeTpl    = sel.getAttribute('data-route-template'); // "/r/__SLUG__"
  const prevValue   = sel.value && sel.value.toLowerCase();

  sel.innerHTML = '';
  allowedTargets.forEach(t => {
    const opt = document.createElement('option');
    opt.value = t;
    opt.textContent = t.toUpperCase();
    opt.setAttribute('data-slug', (targetToSlug[t] || ''));
    sel.appendChild(opt);
  });

  // Selección por defecto:
  if (prevValue && allowedTargets.includes(prevValue)) {
    sel.value = prevValue;
  } else if (allowedTargets.length) {
    sel.value = allowedTargets[0];
  }

  // Redirección si el target pertenece a otro conversor
  setupRedirectOnly();

  function setupRedirectOnly(){
    sel.addEventListener('change', () => {
      const opt  = sel.options[sel.selectedIndex];
      const slug = opt?.getAttribute('data-slug');
      if (slug && slug !== currentSlug) {
        window.location.href = routeTpl.replace('__SLUG__', slug);
      }
      // si no cambia el slug, submit normal del form actual
    });
  }
});
</script>
{% endblock %}
